Why Learn (with) Sophie?
===============================

Sophie is different.

Most currently-popular first programming languages have quite a lot in common:

* You need lots of syntax to get things done, which distracts you from the essentials of comp-sci and/or software engineering.
* You have to spell out a particular ordering of sub-tasks.
* Confusing early design mistakes leave traps and zaps for newcomers and experts alike.
  They can't be fixed out of concern for backwards-compatibility.
  (JavaScript in particular is infamous for this.)
* They work by changing internal state from one step to the next,
  which puts the focus on *how it works* at the expense of *what it does*.
  (That forces you to consider time and sequence when you try to understand some code.)
* They're object-oriented, meaning ... something beyond the scope of this chapter,
  but it sure won't help you in the early stages of learning to program.
* They make only the most cursory review of your code before carrying out your instructions,
  so that you can see programming errors happen while your code is operating.
  (If you've ever seen the word "undefined" in a web page, that's an example.)
* They have enormous communities online -- which is probably an advantage.

Sophie is different on all accounts.

* Sophie is relatively small and simple. There's not a lot of fancy syntax or weird special cases.
* Sophie has *call-by-need*. That lets you focus on meaning, not a particular ordering of sub-tasks.
  Sophie will figure out a sensible ordering of tasks automatically.
* Sophie is youthful and thus able to stay consistent with a vision, not an installed base.
  (Fresh new mistakes, in other words. But anyway, more leeway to adapt.)
* Sophie is functionally pure. That means *meaning is eternal* and you don't have to worry about
  changes behind your back. That may also sound impossibly constraining, but trust me: it's fine.
* Sophie ... doesn't dirty herself with *objects* of the usual sort. (There is a better way.)
* Sophie is fastidious about preventing errors up front, before they cause trouble during operation.
  Through *strong static type inference*, Sophie can check in advance for many kinds of
  latent problems that testing alone might not catch -- which can save you a whole mess of effort.

.. note::
    The type checker is now always on, since it is *mostly* finished and it doesn't cause a problem in practice.
    It can still be too permissive around record field access,
    but this discrepancy will soon be cleaned up, and hopefully in a nice generic way.

Moreover, learning Sophie will affect you in different ways from learning a conventional starter-language.
Sophie teaches you how to think about problems and design solutions effectively.
When you get fluent in a language like Sophie, each bit of code looks like its own *proof-of-correctness*.
The mental habits you develop learning Sophie will help you write better code in other languages.
When you internalize what Sophie offers, most of the others will seem more or less handicapped.

.. note::
    Just to be clear, Sophie is not finished. You can't yet write the next hit video game in Sophie. Yet.
    But you can do some foundational things, learn some general skills, and make Sophie better along the way.

