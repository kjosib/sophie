# Standard Preamble

# The types called "flag", "number", and "string" are built-in and do not need to be declared.
# The turtle-graphics stuff that used to be here has moved to its own separate library.

import:

foreign "math" where

	e, inf, nan, pi, tau : number;

	acos, acosh, asin, asinh, atan, atanh,
	ceil, cos, cosh, degrees, erf, erfc, exp, expm1,
	abs@"fabs", factorial, floor, gamma,
	lgamma, log, log10, log1p, log2,
	radians, sin, sinh, sqrt,
	tan, tanh, trunc, ulp : (number) -> number;

	isfinite, isinf, isnan : (number) -> flag;

	atan2, comb, copysign, dist, fmod, gcd, lcm, ldexp,
	nextafter, perm, pow, remainder : (number, number) -> number;

end;

foreign "builtins" where
	chr, str : (number) -> string;
	len, ord : (string) -> number;
	int : (number) -> number;
end;

foreign "sophie.adapters.yarn" where
	mid : (string, number, number) -> string;
	val : (string) -> maybe[number];
end;

foreign "operator" where
	strcat@"add" : (string, string) -> string;
end;

# A few of Python's standard math functions are trouble (currently).
	# ``dist`` computes Euclidean distance between two points specified as vectors, but Sophie still lacks these.
	# ``fsum``, ``prod``, and ``hypot`` also work on vectors; same problem. (Pure-Sophie versions are provided.)
	# ``frexp`` returns a tuple, which would confuse the evaluator. It needs an adapter to a known record type.
	# Same goes for ``modf``, except it would be trivial in pure Sophie: ``pair(x-trunc(x), trunc(x))`` or similar.
	# The combinatorics ``comb``, ``perm``, ``gcd``, and ``lcm`` have no analogue in the C library,
	# so the VM does not (yet) support them. Numerical stability is a concern with these.
	# ``factorial(x)`` is equivalent to ``gamma(x+1)`` except that Python uses arbitrary-precision integer math
	# for the factorial. The VM may eventually bother with that, but not today.
	# ``log`` in Python takes an optional base. Sophie does not do optional parameters.
	# Therefore, Sophie's preamble provides ``log_base`` directly as the quotient of logs.
	# At one time it was an alias to Python's ``log``, but C's math library has nothing comparable.
	# ``isqrt`` demands an integer argument, which clashes with the intended semantics of "numbers are numbers".

foreign "sophie.adapters.teletype_adapter"
	where console : Console;
end;

type:

	order is case:
		less;
		same;
		more;
	esac;

	list[x] is CASE:
		 cons(head:x, tail:list[x]);
		 nil;
	ESAC;

	maybe[x] is case:
		this(item:x);
		nope;
	esac;

	pair[a,b] is (fst:a, snd:b);

	Console is agent:
		echo(list[string]);
		read(!(string));
		random(!(number));
	end;

assume:
    xs, ys: list[?];
    xss: list[list[?]];
    predicate: (?)->flag;
    n: number;
    s: string;

define:

	id(x) = x;
	any(xs) = case xs of nil -> no; cons -> xs.head or any(xs.tail); esac;
	all(xs) = case xs of nil -> yes; cons -> xs.head and all(xs.tail); esac;

	map(fn, xs) = case xs of
		nil -> nil;
		cons -> cons(fn(xs.head), map(fn, xs.tail));
	esac;

	filter(predicate, xs) = case xs of
		nil -> nil;
		cons -> cons(xs.head, rest) if predicate(xs.head) else rest where
			rest = filter(predicate, xs.tail);
		end cons;
	esac;

	reduce(fn, strict a, xs) = case xs of
		nil -> a;
		cons -> reduce(fn, fn(a, xs.head), xs.tail);
	esac;

	cat(xs,ys) = case xs of
		nil -> ys;
		cons -> cons(xs.head, cat(xs.tail, ys));
	esac;

	flat(xss) = case xss of
		nil -> nil;
		cons -> cat(xss.head, flat(xss.tail));
	esac;

	take(n, xs) = nil if n < 1 else case xs of
		nil -> nil;
		cons -> cons(xs.head, take(n-1, xs.tail));
	esac;

	drop(n, xs) = xs if n < 1 else case xs of
		nil -> nil;
		cons -> drop(n-1, xs.tail);
	esac;

	sum(xs) = reduce(add, 0, xs) where add(a,b) = a+b; end sum;
	product(xs) = reduce(mul, 1, xs) where mul(a,b) = a*b; end product;
	hypot(xs) = sqrt(sum(map(square, xs))) where square(x) = x*x; end hypot;

	left(s, n) = mid(s, 0, n);
	right(s, n) = mid(s, len(s)-n, len(s));

	join(ss : list[string]) : string
	= reduce(strcat, "", ss);  # Yes, this is O(n^2). Fixing that from within is nontrivial.

	interleave(x, ys) = drop(1, flat(map(prefix, ys))) where prefix(y)=cons(x, cons(y, nil)); end interleave;

	each_chr(s) = from(0) where
		from(n) = nil if n >= len(s) else cons(mid(s,n,1), from(n+1));
	end each_chr;

	EOL = chr(10);
	
	log_base(n, base) = log(n) / log(base);
	
	length(xs) = reduce(fn, 0, xs) where fn(a,_) = a+1; end length;
	
	index(n, xs, otherwise) = case drop(n, xs) as e of
		nil -> otherwise;
		cons -> e.head;
	esac;
	
	iota(start, stop) : list[number]
		# Count off a half-open range, stepping by one.
		# For example, iota(3, 7) = [3,4,5,6]
		# You can also start from an offset: iota(2.5, 4) = [2.5, 3.5]
	= nil if start >= stop else cons(start, iota(start+1, stop));

end.
