# The vast bulk of the part-one solution gets reused in part two.
# This mostly boiled down to some text processing and a list-contains
# function which is likely to get promoted to the standard library.

import:

"common" (slice);

assume:
s : string;
xs: list;

define:

nr_winning(line) = length(filter(is_winning, numbers_you_have)) where
	winning_numbers = nums_in(mid(line, 10, 29));
	numbers_you_have = nums_in(mid(line, 42, 74));
	is_winning(nr) = contains(nr, winning_numbers);
end nr_winning;

nums_in(s) = map(surely, map(val, split_on_whitespace(s)));

split_on_whitespace(s) = split_on_whitespace_at(0, s);

split_on_whitespace_at(offset, s) = case
	when offset >= len(s) then nil;
	when is_space_at(offset) then split_on_whitespace_at(offset+1, s);
	else cons(slice(s, offset, after), split_on_whitespace_at(after, s));
esac where
	is_space_at(i) = is_space(mid(s, i, 1));
	after = either(first(is_space_at, iota(offset+1, len(s))), len(s));
end split_on_whitespace_at;

is_space(ch) = ch == " ";

contains(x, xs) = case xs of
	nil -> no;
	cons -> xs.head == x or contains(x, xs.tail);
esac;
