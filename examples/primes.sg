# This one's a bit more meat on the bones.

define:

primes(max) -> list[int] = NIL IF max < 2 ELSE cons(2, odd_primes) where
	odd_primes = more_primes(0, cons(4, map(square, odd_primes)), 3);
	more_primes(bound, squares, candidate_prime) = CASE
		WHEN candidate_prime > max THEN NIL;
		WHEN candidate_prime > squares.head THEN more_primes(bound+1, squares.tail, candidate_prime);
		WHEN is_prime THEN cons(candidate_prime, successors);
		ELSE successors;
	ESAC where
		is_prime = NOT any (map(is_divisor, take(bound, odd_primes)));
		is_divisor(p) = candidate_prime MOD p == 0;
		successors = more_primes(bound, squares, candidate_prime+2);
	end more_primes;
end primes;


some_squares = map(square, [1,2,3]);

square(x) = x * x;

any(xs) = xs != nil and (xs.head or any(xs.tail));
map(fn, elts) = nil if elts == nil else cons(fn(elts.head), map(fn, elts.tail));
take(n, xs) = nil if n < 1 else cons(xs.head, take(n-1, xs.tail));


begin:
	"Here's a list of square numbers:";
	some_squares;
	"Here are the first few dozen prime numbers:";
	primes(256);
end.
